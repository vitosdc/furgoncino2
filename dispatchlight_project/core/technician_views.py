# core/technician_views.py - NUOVO FILE - Views dedicate ai tecnicifrom django.shortcuts import render, get_object_or_404, redirectfrom django.contrib.auth.mixins import LoginRequiredMixinfrom django.views.generic import TemplateView, ListView, DetailView, UpdateViewfrom django.contrib import messagesfrom django.urls import reverse_lazyfrom django.utils import timezonefrom django.db.models import Q, Count, Avg, Sumfrom datetime import datetime, timedelta, datefrom .models import WorkOrder, Technician, Expense, Companyfrom .mixins import TechnicianAccessMixin, TechnicianOwnDataMixinfrom .forms import TechnicianStatusUpdateFormclass TechnicianDashboardView(TechnicianAccessMixin, TemplateView):    """Dashboard principale per i tecnici"""    template_name = 'core/technician/dashboard.html'        def dispatch(self, request, *args, **kwargs):        # Se è proprietario, reindirizza alla dashboard normale        if self.is_company_owner():            return redirect('core:dashboard')        return super().dispatch(request, *args, **kwargs)        def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)                technician = self.get_user_technician()        if not technician:            context['error'] = 'Profilo tecnico non trovato'            return context                company = technician.company        today = timezone.now().date()                # Ordini del tecnico        my_orders = WorkOrder.objects.filter(technician=technician)                # Statistiche personali        context.update({            'technician': technician,            'company': company,                        # Ordini attuali            'pending_orders': my_orders.filter(status='ASSIGNED').count(),            'active_orders': my_orders.filter(status__in=['EN_ROUTE', 'ON_SITE']).count(),            'today_completed': my_orders.filter(                status='COMPLETED',                completed_at__date=today            ).count(),                        # Ordini imminenti (prossime 48 ore)            'upcoming_orders': my_orders.filter(                status='ASSIGNED',                scheduled_date__lte=timezone.now() + timedelta(hours=48),                scheduled_date__gte=timezone.now()            ).order_by('scheduled_date')[:5],                        # Ordini attivi            'current_active_orders': my_orders.filter(                status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']            ).order_by('created_at')[:10],                        # Statistiche settimanali            'week_stats': self._get_week_stats(technician),                        # Ordini recenti completati            'recent_completed': my_orders.filter(                status='COMPLETED'            ).order_by('-completed_at')[:5],        })                return context        def _get_week_stats(self, technician):        """Statistiche della settimana corrente"""        today = timezone.now().date()        week_start = today - timedelta(days=today.weekday())                week_orders = WorkOrder.objects.filter(            technician=technician,            created_at__date__gte=week_start        )                return {            'total': week_orders.count(),            'completed': week_orders.filter(status='COMPLETED').count(),            'pending': week_orders.filter(status='ASSIGNED').count(),            'revenue': week_orders.filter(                status='COMPLETED',                final_price__isnull=False            ).aggregate(total=Sum('final_price'))['total'] or 0        }class TechnicianOrderListView(TechnicianAccessMixin, ListView):    """Lista ordini del tecnico"""    model = WorkOrder    template_name = 'core/technician/order_list.html'    context_object_name = 'orders'    paginate_by = 20        def get_queryset(self):        technician = self.get_user_technician()        if not technician:            return WorkOrder.objects.none()                queryset = WorkOrder.objects.filter(technician=technician)                # Filtri        status = self.request.GET.get('status')        if status:            queryset = queryset.filter(status=status)                period = self.request.GET.get('period')        if period:            days = int(period)            start_date = timezone.now().date() - timedelta(days=days)            queryset = queryset.filter(created_at__date__gte=start_date)                return queryset.order_by('-created_at')        def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)        technician = self.get_user_technician()                if technician:            context.update({                'technician': technician,                'status_choices': WorkOrder.STATUS_CHOICES,                'current_status': self.request.GET.get('status', ''),                'current_period': self.request.GET.get('period', '30'),            })                return contextclass TechnicianOrderDetailView(TechnicianAccessMixin, DetailView):    """Dettaglio ordine per il tecnico"""    model = WorkOrder    template_name = 'core/technician/order_detail.html'    context_object_name = 'order'        def get_queryset(self):        technician = self.get_user_technician()        if not technician:            return WorkOrder.objects.none()        return WorkOrder.objects.filter(technician=technician)        def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)        context['expenses'] = self.object.expenses.filter(technician=self.get_user_technician())        context['status_form'] = TechnicianStatusUpdateForm()        return contextclass TechnicianOrderUpdateView(TechnicianAccessMixin, UpdateView):    """Aggiornamento stato ordine da parte del tecnico"""    model = WorkOrder    form_class = TechnicianStatusUpdateForm    template_name = 'core/technician/order_update.html'        def get_queryset(self):        technician = self.get_user_technician()        if not technician:            return WorkOrder.objects.none()        # Solo ordini assegnati al tecnico e non ancora completati        return WorkOrder.objects.filter(            technician=technician,            status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']        )        def form_valid(self, form):        order = form.instance        new_status = form.cleaned_data['status']                # Aggiorna timestamp appropriati        if new_status == 'EN_ROUTE' and not order.started_at:            order.started_at = timezone.now()        elif new_status == 'ON_SITE' and not order.started_at:            order.started_at = timezone.now()        elif new_status == 'COMPLETED':            order.completed_at = timezone.now()            if not order.started_at:                order.started_at = timezone.now()                # Salva note del tecnico        if form.cleaned_data.get('notes'):            order.technician_notes = form.cleaned_data['notes']                if form.cleaned_data.get('work_performed'):            order.work_performed = form.cleaned_data['work_performed']                if form.cleaned_data.get('materials_used'):            order.materials_used = form.cleaned_data['materials_used']                if form.cleaned_data.get('final_price'):            order.final_price = form.cleaned_data['final_price']                messages.success(            self.request,             f'Ordine {order.order_number} aggiornato con successo!'        )                return super().form_valid(form)        def get_success_url(self):        return reverse_lazy('core:technician_order_detail', kwargs={'pk': self.object.pk})class TechnicianStatsView(TechnicianAccessMixin, TemplateView):    """Statistiche personali del tecnico"""    template_name = 'core/technician/stats.html'        def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)        technician = self.get_user_technician()                if not technician:            context['error'] = 'Profilo tecnico non trovato'            return context                # Periodo di analisi (default 30 giorni)        days = int(self.request.GET.get('days', 30))        end_date = timezone.now().date()        start_date = end_date - timedelta(days=days)                orders_in_period = WorkOrder.objects.filter(            technician=technician,            created_at__date__gte=start_date,            created_at__date__lte=end_date        )                # Statistiche generali        total_orders = orders_in_period.count()        completed_orders = orders_in_period.filter(status='COMPLETED').count()        completion_rate = (completed_orders / total_orders * 100) if total_orders > 0 else 0                # Fatturato        revenue = orders_in_period.filter(            status='COMPLETED',            final_price__isnull=False        ).aggregate(total=Sum('final_price'))['total'] or 0                # Tempo medio di completamento        avg_completion_time = orders_in_period.filter(            status='COMPLETED',            started_at__isnull=False,            completed_at__isnull=False        ).aggregate(            avg_time=Avg(timezone.now() - timezone.now())  # Placeholder        )                # Ordini per giorno (ultimi 7 giorni)        daily_stats = []        for i in range(7):            day = end_date - timedelta(days=i)            day_orders = orders_in_period.filter(created_at__date=day).count()            daily_stats.append({                'date': day,                'orders': day_orders            })        daily_stats.reverse()                # Distribuzione per priorità        priority_stats = orders_in_period.values('priority').annotate(            count=Count('id')        ).order_by('priority')                context.update({            'technician': technician,            'period_days': days,            'start_date': start_date,            'end_date': end_date,                        # Statistiche principali            'total_orders': total_orders,            'completed_orders': completed_orders,            'pending_orders': orders_in_period.filter(status='ASSIGNED').count(),            'cancelled_orders': orders_in_period.filter(status='CANCELLED').count(),            'completion_rate': round(completion_rate, 1),            'total_revenue': revenue,            'avg_order_value': revenue / completed_orders if completed_orders > 0 else 0,                        # Grafici            'daily_stats': daily_stats,            'priority_stats': list(priority_stats),                        # Confronto con periodo precedente            'previous_period_stats': self._get_previous_period_stats(technician, start_date, days),        })                return context        def _get_previous_period_stats(self, technician, current_start, days):        """Statistiche del periodo precedente per confronto"""        prev_end = current_start - timedelta(days=1)        prev_start = prev_end - timedelta(days=days)                prev_orders = WorkOrder.objects.filter(            technician=technician,            created_at__date__gte=prev_start,            created_at__date__lte=prev_end        )                prev_total = prev_orders.count()        prev_completed = prev_orders.filter(status='COMPLETED').count()        prev_revenue = prev_orders.filter(            status='COMPLETED',            final_price__isnull=False        ).aggregate(total=Sum('final_price'))['total'] or 0                return {            'total_orders': prev_total,            'completed_orders': prev_completed,            'total_revenue': prev_revenue,        }class TechnicianProfileView(TechnicianAccessMixin, DetailView):    """Profilo del tecnico (vista propria)"""    model = Technician    template_name = 'core/technician/profile.html'    context_object_name = 'technician'        def get_object(self):        return self.get_user_technician()class TechnicianUpcomingOrdersView(TechnicianAccessMixin, ListView):    """Ordini imminenti del tecnico"""    model = WorkOrder    template_name = 'core/technician/upcoming_orders.html'    context_object_name = 'orders'        def get_queryset(self):        technician = self.get_user_technician()        if not technician:            return WorkOrder.objects.none()                # Ordini assegnati con data futura o nelle prossime 48 ore        upcoming_limit = timezone.now() + timedelta(hours=48)                return WorkOrder.objects.filter(            technician=technician,            status='ASSIGNED',            scheduled_date__lte=upcoming_limit        ).order_by('scheduled_date')        def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)        context['technician'] = self.get_user_technician()        return context