# core/api_views.py - API AGGIORNATE CON CONTROLLO AUTORIZZAZIONIfrom django.http import JsonResponsefrom django.views import Viewfrom django.contrib.auth.mixins import LoginRequiredMixinfrom django.views.decorators.csrf import csrf_exemptfrom django.utils.decorators import method_decoratorfrom django.utils import timezonefrom django.db.models import Count, Qimport jsonimport loggingfrom .models import WorkOrder, Technician, Companyfrom .mixins import CompanyAccessMixin, OwnerRequiredMixinlogger = logging.getLogger(__name__)class OwnerOnlyAPIView(OwnerRequiredMixin, View):    """Base class per API che possono essere usate solo dai proprietari"""        def dispatch(self, request, *args, **kwargs):        if not self.is_company_owner():            return JsonResponse({'error': 'Solo il proprietario dell\'azienda può accedere a questa API'}, status=403)        return super().dispatch(request, *args, **kwargs)class LiveMapDataView(OwnerOnlyAPIView):    """API endpoint per dati mappa in tempo reale - SOLO PROPRIETARI"""        def get(self, request):        try:            company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Prepara dati tecnici            technicians_data = []            technicians = Technician.objects.filter(                company=company,                 is_active=True            ).select_related('user').annotate(                current_orders=Count('work_orders', filter=Q(work_orders__status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']))            )                        for tech in technicians:                # Coordinate simulate per demo (sostituire con dati GPS reali)                lat, lng = self._get_demo_coordinates(tech.id)                                technicians_data.append({                    'id': tech.id,                    'name': tech.user.get_full_name(),                    'phone': str(tech.phone),                    'vehicle': tech.vehicle_plate,                    'is_active': tech.is_active,                    'current_orders': tech.current_orders,                    'completed_today': self._get_completed_today_count(tech),                    'lat': lat,                    'lng': lng,                    'last_update': tech.last_location_update.isoformat() if tech.last_location_update else None,                    'status': tech.get_current_status() if hasattr(tech, 'get_current_status') else 'AVAILABLE'                })                        # Prepara dati ordini            orders_data = []            orders = WorkOrder.objects.filter(                company=company,                status__in=['PENDING', 'ASSIGNED']            ).select_related('customer', 'technician__user')                        for order in orders:                # Coordinate simulate per demo (sostituire con geocoding dell'indirizzo)                lat, lng = self._geocode_address(order.service_address)                                orders_data.append({                    'id': str(order.id),                    'order_number': order.order_number,                    'title': order.title,                    'description': order.description,                    'customer_name': order.customer.name,                    'customer_phone': str(order.customer.phone),                    'priority': order.priority,                    'priority_display': order.get_priority_display(),                    'status': order.status,                    'service_address': order.service_address,                    'created_at': order.created_at.isoformat(),                    'technician_id': order.technician.id if order.technician else None,                    'technician_name': order.technician.user.get_full_name() if order.technician else None,                    'lat': lat,                    'lng': lng,                    'estimated_price': float(order.estimated_price) if order.estimated_price else None                })                        return JsonResponse({                'technicians': technicians_data,                'orders': orders_data,                'timestamp': timezone.now().isoformat(),                'status': 'success'            })                    except Exception as e:            logger.error(f'Errore in LiveMapDataView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno del server'}, status=500)        def _get_demo_coordinates(self, tech_id):        """Genera coordinate simulate per demo"""        base_lat = 41.9028        base_lng = 12.4964                import random        random.seed(tech_id)                lat_offset = random.uniform(-0.1, 0.1)        lng_offset = random.uniform(-0.1, 0.1)                return base_lat + lat_offset, base_lng + lng_offset        def _geocode_address(self, address):        """Geocoding semplificato per demo"""        base_lat = 41.9028        base_lng = 12.4964                import hashlib        hash_obj = hashlib.md5(address.encode())        hash_int = int(hash_obj.hexdigest()[:8], 16)                lat_offset = ((hash_int % 200) - 100) / 1000        lng_offset = (((hash_int // 200) % 200) - 100) / 1000                return base_lat + lat_offset, base_lng + lng_offset        def _get_completed_today_count(self, technician):        """Conta ordini completati oggi dal tecnico"""        from datetime import date        return WorkOrder.objects.filter(            technician=technician,            status='COMPLETED',            completed_at__date=date.today()        ).count()@method_decorator(csrf_exempt, name='dispatch')class AssignOrderView(OwnerOnlyAPIView):    """API per assegnare rapidamente un ordine a un tecnico - SOLO PROPRIETARI"""        def post(self, request):        try:            data = json.loads(request.body)            order_id = data.get('order_id')            technician_id = data.get('technician_id')                        # Validazione input            if not order_id or not technician_id:                return JsonResponse({'error': 'order_id e technician_id sono richiesti'}, status=400)                        company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Verifica ordine            try:                order = WorkOrder.objects.get(id=order_id, company=company)            except WorkOrder.DoesNotExist:                return JsonResponse({'error': 'Ordine non trovato'}, status=404)                        # Verifica tecnico            try:                technician = Technician.objects.get(id=technician_id, company=company)            except Technician.DoesNotExist:                return JsonResponse({'error': 'Tecnico non trovato'}, status=404)                        # Verifica che l'ordine sia assegnabile            if order.status not in ['PENDING']:                return JsonResponse({                    'error': f'Ordine in stato {order.get_status_display()}, non assegnabile',                    'current_status': order.status                }, status=400)                        # Verifica che il tecnico sia attivo            if not technician.is_active:                return JsonResponse({                    'error': f'Tecnico {technician.user.get_full_name()} non è attivo',                    'technician_status': 'inactive'                }, status=400)                        # Controlla carico di lavoro tecnico (opzionale)            current_workload = WorkOrder.objects.filter(                technician=technician,                status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']            ).count()                        max_workload = 5  # Massimo 5 ordini contemporanei per tecnico            if current_workload >= max_workload:                return JsonResponse({                    'error': f'Tecnico {technician.user.get_full_name()} ha già {current_workload} ordini attivi',                    'suggestion': 'Considera di assegnare a un altro tecnico',                    'current_workload': current_workload,                    'max_workload': max_workload                }, status=400)                        # Assegna ordine            old_status = order.status            order.technician = technician            order.status = 'ASSIGNED'            order.assigned_at = timezone.now()            order.save()                        # Log dell'assegnazione            logger.info(f'Ordine {order.order_number} assegnato da {request.user.username} a {technician.user.get_full_name()}')                        # Calcola distanza stimata (se disponibili coordinate)            estimated_distance = None            estimated_time = None            if (hasattr(technician, 'current_latitude') and technician.current_latitude and                 hasattr(order, 'service_latitude') and order.service_latitude):                estimated_distance = self._calculate_distance(                    float(technician.current_latitude), float(technician.current_longitude),                    float(order.service_latitude), float(order.service_longitude)                )                estimated_time = max(15, int(estimated_distance * 2.5))  # Min 15 minuti                        response_data = {                'success': True,                'message': f'Ordine {order.order_number} assegnato a {technician.user.get_full_name()}',                'order': {                    'id': str(order.id),                    'order_number': order.order_number,                    'status': order.status,                    'old_status': old_status,                    'assigned_at': order.assigned_at.isoformat(),                    'technician_name': technician.user.get_full_name(),                    'technician_id': technician.id,                    'priority': order.priority,                    'estimated_distance_km': round(estimated_distance, 1) if estimated_distance else None,                    'estimated_time_minutes': estimated_time                },                'technician': {                    'id': technician.id,                    'name': technician.user.get_full_name(),                    'new_workload': current_workload + 1,                    'phone': str(technician.phone)                }            }                        return JsonResponse(response_data)                    except json.JSONDecodeError:            return JsonResponse({'error': 'Formato JSON non valido'}, status=400)        except Exception as e:            logger.error(f'Errore in AssignOrderView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno durante l\'assegnazione'}, status=500)        def _calculate_distance(self, lat1, lng1, lat2, lng2):        """Calcola distanza in km tra due coordinate"""        from math import radians, sin, cos, sqrt, atan2                R = 6371  # Raggio Terra in km                lat1, lng1, lat2, lng2 = map(radians, [lat1, lng1, lat2, lng2])                dlat = lat2 - lat1        dlng = lng2 - lng1                a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlng/2)**2        c = 2 * atan2(sqrt(a), sqrt(1-a))                return R * c@method_decorator(csrf_exempt, name='dispatch')class UpdateTechnicianLocationView(CompanyAccessMixin, View):    """API per aggiornare la posizione GPS di un tecnico - TECNICI E PROPRIETARI"""        def post(self, request):        try:            data = json.loads(request.body)            technician_id = data.get('technician_id')            latitude = data.get('latitude')            longitude = data.get('longitude')                        # Validazione input            if not all([technician_id, latitude, longitude]):                return JsonResponse({'error': 'technician_id, latitude e longitude sono richiesti'}, status=400)                        try:                latitude = float(latitude)                longitude = float(longitude)            except (ValueError, TypeError):                return JsonResponse({'error': 'Coordinate non valide'}, status=400)                        # Validazione range coordinate (mondo)            if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):                return JsonResponse({'error': 'Coordinate fuori dal range valido'}, status=400)                        company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Verifica tecnico            try:                technician = Technician.objects.get(id=technician_id, company=company)            except Technician.DoesNotExist:                return JsonResponse({'error': 'Tecnico non trovato'}, status=404)                        # Controllo autorizzazione: il tecnico può aggiornare solo la propria posizione            if not self.is_company_owner():                user_technician = self.get_user_technician()                if not user_technician or user_technician.id != technician.id:                    return JsonResponse({'error': 'Puoi aggiornare solo la tua posizione'}, status=403)                        # Aggiorna posizione            old_lat = technician.current_latitude            old_lng = technician.current_longitude                        if hasattr(technician, 'update_location'):                technician.update_location(latitude, longitude)            else:                technician.current_latitude = latitude                technician.current_longitude = longitude                technician.last_location_update = timezone.now()                technician.save(update_fields=['current_latitude', 'current_longitude', 'last_location_update'])                        # Calcola distanza spostamento se aveva posizione precedente            distance_moved = None            if old_lat and old_lng:                distance_moved = self._calculate_distance(                    float(old_lat), float(old_lng), latitude, longitude                ) * 1000  # in metri                        logger.info(f'Posizione aggiornata per tecnico {technician.user.get_full_name()}: {latitude}, {longitude}')                        return JsonResponse({                'success': True,                'message': 'Posizione aggiornata con successo',                'technician': {                    'id': technician.id,                    'name': technician.user.get_full_name(),                    'latitude': float(technician.current_latitude),                    'longitude': float(technician.current_longitude),                    'last_update': technician.last_location_update.isoformat(),                    'distance_moved_meters': round(distance_moved, 1) if distance_moved else None                }            })                    except json.JSONDecodeError:            return JsonResponse({'error': 'Formato JSON non valido'}, status=400)        except Exception as e:            logger.error(f'Errore in UpdateTechnicianLocationView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno durante l\'aggiornamento'}, status=500)        def _calculate_distance(self, lat1, lng1, lat2, lng2):        """Calcola distanza in km tra due coordinate"""        from math import radians, sin, cos, sqrt, atan2                R = 6371        lat1, lng1, lat2, lng2 = map(radians, [lat1, lng1, lat2, lng2])                dlat = lat2 - lat1        dlng = lng2 - lng1                a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlng/2)**2        c = 2 * atan2(sqrt(a), sqrt(1-a))                return R * cclass MapStatsView(OwnerOnlyAPIView):    """API per statistiche mappa in tempo reale - SOLO PROPRIETARI"""        def get(self, request):        try:            company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Statistiche tecnici            total_technicians = Technician.objects.filter(company=company).count()            active_technicians = Technician.objects.filter(company=company, is_active=True).count()                        # Tecnici online (aggiornamento GPS recente)            online_threshold = timezone.now() - timezone.timedelta(minutes=10)            online_technicians = Technician.objects.filter(                company=company,                is_active=True,                last_location_update__gte=online_threshold            ).count()                        # Tecnici occupati            working_technicians = Technician.objects.filter(                company=company,                is_active=True,                work_orders__status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']            ).distinct().count()                        # Statistiche ordini            total_orders = WorkOrder.objects.filter(                company=company            ).exclude(status__in=['COMPLETED', 'CANCELLED']).count()                        pending_orders = WorkOrder.objects.filter(company=company, status='PENDING').count()            assigned_orders = WorkOrder.objects.filter(company=company, status='ASSIGNED').count()            active_orders = WorkOrder.objects.filter(                company=company,                 status__in=['EN_ROUTE', 'ON_SITE']            ).count()                        urgent_orders = WorkOrder.objects.filter(                company=company,                priority='URGENT',                status__in=['PENDING', 'ASSIGNED', 'EN_ROUTE', 'ON_SITE']            ).count()                        # Statistiche oggi            from datetime import date            today = date.today()            orders_today = WorkOrder.objects.filter(                company=company,                created_at__date=today            ).count()                        completed_today = WorkOrder.objects.filter(                company=company,                completed_at__date=today,                status='COMPLETED'            ).count()                        return JsonResponse({                'technicians': {                    'total': total_technicians,                    'active': active_technicians,                    'online': online_technicians,                    'working': working_technicians,                    'available': max(0, online_technicians - working_technicians)                },                'orders': {                    'total': total_orders,                    'pending': pending_orders,                    'assigned': assigned_orders,                    'active': active_orders,                    'urgent': urgent_orders,                    'today': orders_today,                    'completed_today': completed_today                },                'performance': {                    'completion_rate_today': round((completed_today / orders_today * 100) if orders_today > 0 else 0, 1),                    'avg_orders_per_technician': round(total_orders / max(1, active_technicians), 1),                    'utilization_rate': round((working_technicians / max(1, active_technicians) * 100), 1)                },                'timestamp': timezone.now().isoformat(),                'status': 'success'            })                    except Exception as e:            logger.error(f'Errore in MapStatsView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno del server'}, status=500)class NearbyTechniciansView(OwnerOnlyAPIView):    """API per trovare tecnici vicini a un indirizzo - SOLO PROPRIETARI"""        def get(self, request):        try:            lat = request.GET.get('lat')            lng = request.GET.get('lng')            max_distance = float(request.GET.get('max_distance', 10))  # km                        if not lat or not lng:                return JsonResponse({'error': 'Parametri lat e lng sono richiesti'}, status=400)                        try:                lat = float(lat)                lng = float(lng)            except (ValueError, TypeError):                return JsonResponse({'error': 'Coordinate non valide'}, status=400)                        if max_distance <= 0 or max_distance > 100:                max_distance = 10  # Default sicuro                        company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Trova tecnici vicini            nearby_technicians = []            technicians = Technician.objects.filter(                company=company,                 is_active=True,                current_latitude__isnull=False,                current_longitude__isnull=False            ).select_related('user').annotate(                current_orders=Count('work_orders', filter=Q(work_orders__status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']))            )                        for tech in technicians:                if tech.current_latitude and tech.current_longitude:                    distance = self._calculate_distance(                        lat, lng,                         float(tech.current_latitude), float(tech.current_longitude)                    )                                        if distance <= max_distance:                        # Determina disponibilità                        is_available = tech.current_orders == 0                        estimated_arrival = max(10, int(distance * 2.5))  # Min 10 minuti                                                nearby_technicians.append({                            'id': tech.id,                            'name': tech.user.get_full_name(),                            'distance': round(distance, 2),                            'distance_formatted': self._format_distance(distance),                            'estimated_arrival_minutes': estimated_arrival,                            'current_orders': tech.current_orders,                            'is_available': is_available,                            'status': 'AVAILABLE' if is_available else 'BUSY',                            'phone': str(tech.phone),                            'vehicle': tech.vehicle_plate or 'N/A',                            'last_update': tech.last_location_update.isoformat() if tech.last_location_update else None,                            'coordinates': {                                'lat': float(tech.current_latitude),                                'lng': float(tech.current_longitude)                            }                        })                        # Ordina per distanza e disponibilità            nearby_technicians.sort(key=lambda x: (not x['is_available'], x['distance']))                        return JsonResponse({                'technicians': nearby_technicians,                'search_center': {'lat': lat, 'lng': lng},                'max_distance_km': max_distance,                'count': len(nearby_technicians),                'available_count': len([t for t in nearby_technicians if t['is_available']]),                'status': 'success',                'timestamp': timezone.now().isoformat()            })                    except Exception as e:            logger.error(f'Errore in NearbyTechniciansView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno del server'}, status=500)        def _calculate_distance(self, lat1, lng1, lat2, lng2):        """Calcola distanza in km tra due coordinate"""        from math import radians, sin, cos, sqrt, atan2                R = 6371        lat1, lng1, lat2, lng2 = map(radians, [lat1, lng1, lat2, lng2])                dlat = lat2 - lat1        dlng = lng2 - lng1                a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlng/2)**2        c = 2 * atan2(sqrt(a), sqrt(1-a))                return R * c        def _format_distance(self, km):        """Formatta distanza per display"""        if km < 1:            return f"{int(km * 1000)}m"        elif km < 10:            return f"{km:.1f}km"        else:            return f"{int(km)}km"@method_decorator(csrf_exempt, name='dispatch')class BulkAssignOrdersView(OwnerOnlyAPIView):    """API per assegnazione multipla di ordini - SOLO PROPRIETARI"""        def post(self, request):        try:            data = json.loads(request.body)            assignments = data.get('assignments', [])                        if not assignments or not isinstance(assignments, list):                return JsonResponse({'error': 'Lista assignments richiesta'}, status=400)                        if len(assignments) > 20:  # Limite sicurezza                return JsonResponse({'error': 'Massimo 20 assegnazioni per volta'}, status=400)                        company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        successful_assignments = []            failed_assignments = []                        # Processa ogni assegnazione            for i, assignment in enumerate(assignments):                order_id = assignment.get('order_id')                technician_id = assignment.get('technician_id')                                if not order_id or not technician_id:                    failed_assignments.append({                        'index': i,                        'order_id': order_id,                        'technician_id': technician_id,                        'reason': 'order_id e technician_id richiesti'                    })                    continue                                try:                    # Verifica ordine                    order = WorkOrder.objects.get(id=order_id, company=company)                    technician = Technician.objects.get(id=technician_id, company=company)                                        # Controlli                    if order.status != 'PENDING':                        failed_assignments.append({                            'index': i,                            'order_id': order_id,                            'order_number': order.order_number,                            'reason': f'Ordine in stato {order.get_status_display()}'                        })                        continue                                        if not technician.is_active:                        failed_assignments.append({                            'index': i,                            'order_id': order_id,                            'technician_id': technician_id,                            'reason': f'Tecnico {technician.user.get_full_name()} non attivo'                        })                        continue                                        # Controlla carico                    current_workload = WorkOrder.objects.filter(                        technician=technician,                        status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']                    ).count()                                        if current_workload >= 5:  # Limite                        failed_assignments.append({                            'index': i,                            'order_id': order_id,                            'reason': f'Tecnico {technician.user.get_full_name()} sovraccarico ({current_workload} ordini)'                        })                        continue                                        # Assegna                    order.technician = technician                    order.status = 'ASSIGNED'                    order.assigned_at = timezone.now()                    order.save()                                        successful_assignments.append({                        'index': i,                        'order_id': order_id,                        'order_number': order.order_number,                        'technician_id': technician_id,                        'technician_name': technician.user.get_full_name(),                        'assigned_at': order.assigned_at.isoformat()                    })                                        logger.info(f'Bulk assignment: {order.order_number} -> {technician.user.get_full_name()}')                                    except WorkOrder.DoesNotExist:                    failed_assignments.append({                        'index': i,                        'order_id': order_id,                        'reason': 'Ordine non trovato'                    })                except Technician.DoesNotExist:                    failed_assignments.append({                        'index': i,                        'technician_id': technician_id,                        'reason': 'Tecnico non trovato'                    })                except Exception as e:                    failed_assignments.append({                        'index': i,                        'order_id': order_id,                        'reason': f'Errore interno: {str(e)}'                    })                        success_count = len(successful_assignments)            total_count = len(assignments)                        return JsonResponse({                'success': True,                'message': f'Processate {total_count} assegnazioni: {success_count} successi, {len(failed_assignments)} errori',                'successful_assignments': successful_assignments,                'failed_assignments': failed_assignments,                'total_processed': total_count,                'successful_count': success_count,                'failed_count': len(failed_assignments),                'success_rate': round((success_count / total_count * 100), 1) if total_count > 0 else 0,                'timestamp': timezone.now().isoformat()            })                    except json.JSONDecodeError:            return JsonResponse({'error': 'Formato JSON non valido'}, status=400)        except Exception as e:            logger.error(f'Errore in BulkAssignOrdersView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore interno durante l\'assegnazione multipla'}, status=500)class OptimizeRoutesView(OwnerOnlyAPIView):    """API per ottimizzazione automatica percorsi e assegnazioni - SOLO PROPRIETARI"""        def post(self, request):        try:            company = self.get_user_company()            if not company:                return JsonResponse({'error': 'Nessuna azienda associata'}, status=400)                        # Ottieni tecnici disponibili            available_technicians = Technician.objects.filter(                company=company,                is_active=True,                current_latitude__isnull=False,                current_longitude__isnull=False            ).annotate(                current_orders=Count('work_orders', filter=Q(work_orders__status__in=['ASSIGNED', 'EN_ROUTE', 'ON_SITE']))            ).filter(current_orders__lt=3)  # Max 3 ordini per tecnico                        # Ottieni ordini non assegnati            pending_orders = WorkOrder.objects.filter(                company=company,                status='PENDING'            )                        if not available_technicians.exists():                return JsonResponse({                    'success': False,                    'message': 'Nessun tecnico disponibile per l\'ottimizzazione',                    'available_technicians': 0                })                        if not pending_orders.exists():                return JsonResponse({                    'success': False,                    'message': 'Nessun ordine da assegnare',                    'pending_orders': 0                })                        # Algoritmo di ottimizzazione semplificato            optimized_assignments = []                        for order in pending_orders:                # Simula coordinate ordine                order_lat, order_lng = self._get_order_coordinates(order)                                best_technician = None                min_score = float('inf')                                for tech in available_technicians:                    # Calcola distanza                    distance = self._calculate_distance(                        float(tech.current_latitude), float(tech.current_longitude),                        order_lat, order_lng                    )                                        # Fattore priorità ordine                    priority_weight = {'URGENT': 4, 'HIGH': 3, 'NORMAL': 2, 'LOW': 1}                    priority_factor = priority_weight.get(order.priority, 2)                                        # Score: distanza penalizzata da carico lavoro e priorità                    workload_penalty = tech.current_orders * 2  # Penalità per ordini esistenti                    score = distance + workload_penalty - priority_factor                                        if score < min_score:                        min_score = score                        best_technician = tech                                if best_technician:                    optimized_assignments.append({                        'order_id': str(order.id),                        'order_number': order.order_number,                        'technician_id': best_technician.id,                        'technician_name': best_technician.user.get_full_name(),                        'distance_km': round(min_score, 2),                        'priority': order.priority,                        'estimated_time': max(15, int(min_score * 2.5))                    })                                        # Aggiorna carico tecnico per prossime iterazioni                    best_technician.current_orders += 1                        # Applica le assegnazioni se richiesto            apply_assignments = request.GET.get('apply', 'false').lower() == 'true'            actual_assignments = []                        if apply_assignments:                for assignment in optimized_assignments:                    try:                        order = WorkOrder.objects.get(id=assignment['order_id'], company=company)                        technician = Technician.objects.get(id=assignment['technician_id'], company=company)                                                if order.status == 'PENDING' and technician.is_active:                            order.technician = technician                            order.status = 'ASSIGNED'                             order.assigned_at = timezone.now()                            order.save()                                                        actual_assignments.append(assignment)                    except Exception as e:                        logger.error(f'Errore applicazione assegnazione ottimizzata: {e}')                        return JsonResponse({                'success': True,                'message': f'Ottimizzazione completata: {len(optimized_assignments)} assegnazioni proposte',                'optimized_assignments': optimized_assignments,                'applied_assignments': actual_assignments if apply_assignments else [],                'applied': apply_assignments,                'statistics': {                    'available_technicians': available_technicians.count(),                    'pending_orders': pending_orders.count(),                    'optimization_ratio': round(len(optimized_assignments) / pending_orders.count() * 100, 1) if pending_orders.count() > 0 else 0,                    'avg_distance': round(sum(a['distance_km'] for a in optimized_assignments) / len(optimized_assignments), 1) if optimized_assignments else 0                },                'timestamp': timezone.now().isoformat()            })                    except Exception as e:            logger.error(f'Errore in OptimizeRoutesView: {str(e)}', exc_info=True)            return JsonResponse({'error': 'Errore durante l\'ottimizzazione'}, status=500)        def _get_order_coordinates(self, order):        """Ottieni coordinate ordine (simulate per demo)"""        import hashlib        base_lat, base_lng = 41.9028, 12.4964                hash_obj = hashlib.md5(order.service_address.encode())        hash_int = int(hash_obj.hexdigest()[:8], 16)                lat_offset = ((hash_int % 200) - 100) / 1000        lng_offset = (((hash_int // 200) % 200) - 100) / 1000                return base_lat + lat_offset, base_lng + lng_offset        def _calculate_distance(self, lat1, lng1, lat2, lng2):        """Calcola distanza in km"""        from math import radians, sin, cos, sqrt, atan2                R = 6371        lat1, lng1, lat2, lng2 = map(radians, [lat1, lng1, lat2, lng2])                dlat = lat2 - lat1        dlng = lng2 - lng1                a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlng/2)**2        c = 2 * atan2(sqrt(a), sqrt(1-a))                return R * c