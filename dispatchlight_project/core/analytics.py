# core/analytics.py - NUOVO FILE per le analyticsfrom django.db.models import Count, Sum, Avg, Q, Ffrom django.utils import timezonefrom datetime import datetime, timedeltafrom .models import WorkOrder, Customer, Technician, Company, Expenseimport calendarclass AnalyticsService:    """Servizio per calcolare statistiche e analytics"""        def __init__(self, company):        self.company = company        self.now = timezone.now()            def get_overview_stats(self):        """Statistiche generali di overview"""        return {            'total_orders': WorkOrder.objects.filter(company=self.company).count(),            'completed_orders': WorkOrder.objects.filter(                company=self.company,                 status='COMPLETED'            ).count(),            'active_customers': Customer.objects.filter(company=self.company).count(),            'active_technicians': Technician.objects.filter(                company=self.company,                 is_active=True            ).count(),            'total_revenue': WorkOrder.objects.filter(                company=self.company,                status='COMPLETED',                final_price__isnull=False            ).aggregate(total=Sum('final_price'))['total'] or 0,        }        def get_monthly_performance(self, months=12):        """Performance degli ultimi N mesi"""        end_date = self.now.date()        start_date = end_date - timedelta(days=30 * months)                # Raggruppa ordini per mese        monthly_data = []        current_date = start_date                while current_date <= end_date:            month_start = current_date.replace(day=1)            next_month = month_start.replace(                month=month_start.month + 1 if month_start.month < 12 else 1,                year=month_start.year if month_start.month < 12 else month_start.year + 1            )                        orders_count = WorkOrder.objects.filter(                company=self.company,                created_at__gte=month_start,                created_at__lt=next_month            ).count()                        completed_count = WorkOrder.objects.filter(                company=self.company,                created_at__gte=month_start,                created_at__lt=next_month,                status='COMPLETED'            ).count()                        revenue = WorkOrder.objects.filter(                company=self.company,                completed_at__gte=month_start,                completed_at__lt=next_month,                status='COMPLETED',                final_price__isnull=False            ).aggregate(total=Sum('final_price'))['total'] or 0                        monthly_data.append({                'month': calendar.month_name[month_start.month],                'year': month_start.year,                'month_year': f"{calendar.month_name[month_start.month][:3]} {month_start.year}",                'orders_count': orders_count,                'completed_count': completed_count,                'revenue': float(revenue),                'completion_rate': (completed_count / orders_count * 100) if orders_count > 0 else 0            })                        current_date = next_month                    return monthly_data[-12:]  # Ultimi 12 mesi        def get_technician_performance(self):        """Performance dei tecnici"""        technicians = Technician.objects.filter(            company=self.company,            is_active=True        ).annotate(            total_orders=Count('work_orders'),            completed_orders=Count('work_orders', filter=Q(work_orders__status='COMPLETED')),            total_revenue=Sum('work_orders__final_price', filter=Q(work_orders__status='COMPLETED')),            avg_completion_time=Avg(                F('work_orders__completed_at') - F('work_orders__started_at'),                filter=Q(work_orders__status='COMPLETED')            )        )                performance_data = []        for tech in technicians:            completion_rate = (tech.completed_orders / tech.total_orders * 100) if tech.total_orders > 0 else 0                        performance_data.append({                'name': tech.user.get_full_name(),                'total_orders': tech.total_orders,                'completed_orders': tech.completed_orders,                'completion_rate': round(completion_rate, 1),                'total_revenue': float(tech.total_revenue or 0),                'avg_completion_time': self._format_timedelta(tech.avg_completion_time),                'efficiency_score': self._calculate_efficiency_score(tech)            })                    return sorted(performance_data, key=lambda x: x['efficiency_score'], reverse=True)        def get_status_distribution(self):        """Distribuzione degli ordini per stato"""        status_data = WorkOrder.objects.filter(company=self.company).values('status').annotate(            count=Count('id')        ).order_by('status')                status_labels = dict(WorkOrder.STATUS_CHOICES)                return [            {                'status': status_labels.get(item['status'], item['status']),                'count': item['count'],                'percentage': 0  # Calcolato nel template            }            for item in status_data        ]        def get_priority_analysis(self):        """Analisi degli ordini per priorità"""        priority_data = WorkOrder.objects.filter(company=self.company).values('priority').annotate(            count=Count('id'),            avg_completion_time=Avg(                F('completed_at') - F('created_at'),                filter=Q(status='COMPLETED')            )        ).order_by('priority')                priority_labels = dict(WorkOrder.PRIORITY_CHOICES)                return [            {                'priority': priority_labels.get(item['priority'], item['priority']),                'count': item['count'],                'avg_completion_hours': self._timedelta_to_hours(item['avg_completion_time'])            }            for item in priority_data        ]        def get_customer_analysis(self):        """Analisi dei clienti più attivi"""        customers = Customer.objects.filter(company=self.company).annotate(            total_orders=Count('work_orders'),            total_spent=Sum('work_orders__final_price', filter=Q(work_orders__status='COMPLETED')),            last_order_date=Max('work_orders__created_at')        ).order_by('-total_orders')[:10]                return [            {                'name': customer.name,                'total_orders': customer.total_orders,                'total_spent': float(customer.total_spent or 0),                'last_order_date': customer.last_order_date,                'avg_order_value': float(customer.total_spent / customer.total_orders) if customer.total_orders > 0 and customer.total_spent else 0            }            for customer in customers        ]        def get_service_type_analysis(self):        """Analisi dei tipi di servizio più richiesti"""        from django.db.models import Max                service_data = WorkOrder.objects.filter(            company=self.company,            service_type__isnull=False        ).values('service_type__name').annotate(            count=Count('id'),            total_revenue=Sum('final_price', filter=Q(status='COMPLETED')),            avg_price=Avg('final_price', filter=Q(status='COMPLETED'))        ).order_by('-count')                return [            {                'service_name': item['service_type__name'],                'count': item['count'],                'total_revenue': float(item['total_revenue'] or 0),                'avg_price': float(item['avg_price'] or 0)            }            for item in service_data        ]        def get_weekly_schedule_analysis(self):        """Analisi degli ordini per giorno della settimana"""        from django.db.models import Extract                weekly_data = WorkOrder.objects.filter(company=self.company).annotate(            weekday=Extract('created_at', 'week_day')        ).values('weekday').annotate(            count=Count('id')        ).order_by('weekday')                days = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato']                result = {day: 0 for day in days}        for item in weekly_data:            day_name = days[item['weekday'] - 1]            result[day_name] = item['count']                    return [{'day': day, 'count': count} for day, count in result.items()]        def get_financial_summary(self, period_days=30):        """Riepilogo finanziario"""        end_date = self.now.date()        start_date = end_date - timedelta(days=period_days)                current_period = WorkOrder.objects.filter(            company=self.company,            completed_at__gte=start_date,            completed_at__lte=end_date,            status='COMPLETED'        )                previous_start = start_date - timedelta(days=period_days)        previous_period = WorkOrder.objects.filter(            company=self.company,            completed_at__gte=previous_start,            completed_at__lt=start_date,            status='COMPLETED'        )                current_revenue = current_period.aggregate(total=Sum('final_price'))['total'] or 0        previous_revenue = previous_period.aggregate(total=Sum('final_price'))['total'] or 0                # Spese del periodo        current_expenses = Expense.objects.filter(            work_order__company=self.company,            created_at__gte=start_date,            created_at__lte=end_date        ).aggregate(total=Sum('amount'))['total'] or 0                return {            'current_revenue': float(current_revenue),            'previous_revenue': float(previous_revenue),            'revenue_change': self._calculate_percentage_change(current_revenue, previous_revenue),            'current_expenses': float(current_expenses),            'net_profit': float(current_revenue - current_expenses),            'current_orders': current_period.count(),            'previous_orders': previous_period.count(),            'orders_change': self._calculate_percentage_change(current_period.count(), previous_period.count()),            'avg_order_value': float(current_revenue / current_period.count()) if current_period.count() > 0 else 0        }        def _format_timedelta(self, td):        """Formatta timedelta in formato leggibile"""        if not td:            return "N/A"                hours, remainder = divmod(td.total_seconds(), 3600)        minutes, _ = divmod(remainder, 60)        return f"{int(hours)}h {int(minutes)}m"        def _timedelta_to_hours(self, td):        """Converte timedelta in ore decimali"""        if not td:            return 0        return round(td.total_seconds() / 3600, 1)        def _calculate_efficiency_score(self, technician):        """Calcola score di efficienza del tecnico"""        if technician.total_orders == 0:            return 0                completion_rate = technician.completed_orders / technician.total_orders        revenue_factor = min((technician.total_revenue or 0) / 5000, 1)  # Max 5000€                return round((completion_rate * 70 + revenue_factor * 30), 1)        def _calculate_percentage_change(self, current, previous):        """Calcola variazione percentuale"""        if previous == 0:            return 100 if current > 0 else 0        return round(((current - previous) / previous) * 100, 1)