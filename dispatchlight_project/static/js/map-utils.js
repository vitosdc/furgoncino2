// static/js/map-utils.js - NUOVO FILE// Utility e funzioni avanzate per la mappaclass DispatchMapUtils {    constructor() {        this.apiEndpoints = {            mapData: '/api/map-data/',            assignOrder: '/api/assign-order/',            updateLocation: '/api/update-location/',            mapStats: '/api/map-stats/',            nearbyTechnicians: '/api/nearby-technicians/',            bulkAssign: '/api/bulk-assign/'        };                this.refreshInterval = 30000; // 30 secondi        this.isAutoRefreshing = false;        this.refreshTimer = null;    }    // Gestione chiamate API    async makeAPICall(endpoint, method = 'GET', data = null) {        try {            const config = {                method: method,                headers: {                    'Content-Type': 'application/json',                    'X-CSRFToken': this.getCSRFToken()                }            };            if (data && method !== 'GET') {                config.body = JSON.stringify(data);            }            const response = await fetch(endpoint, config);                        if (!response.ok) {                throw new Error(`HTTP error! status: ${response.status}`);            }                        return await response.json();        } catch (error) {            console.error('API call failed:', error);            throw error;        }    }    // Ottieni CSRF token per Django    getCSRFToken() {        const name = 'csrftoken';        let cookieValue = null;        if (document.cookie && document.cookie !== '') {            const cookies = document.cookie.split(';');            for (let i = 0; i < cookies.length; i++) {                const cookie = cookies[i].trim();                if (cookie.substring(0, name.length + 1) === (name + '=')) {                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));                    break;                }            }        }        return cookieValue;    }    // Aggiorna dati mappa    async refreshMapData() {        try {            const data = await this.makeAPICall(this.apiEndpoints.mapData);            return data;        } catch (error) {            console.error('Failed to refresh map data:', error);            throw error;        }    }    // Assegna ordine via API    async assignOrder(orderId, technicianId) {        try {            const data = await this.makeAPICall(this.apiEndpoints.assignOrder, 'POST', {                order_id: orderId,                technician_id: technicianId            });            return data;        } catch (error) {            console.error('Failed to assign order:', error);            throw error;        }    }    // Aggiorna posizione tecnico    async updateTechnicianLocation(technicianId, latitude, longitude) {        try {            const data = await this.makeAPICall(this.apiEndpoints.updateLocation, 'POST', {                technician_id: technicianId,                latitude: latitude,                longitude: longitude            });            return data;        } catch (error) {            console.error('Failed to update location:', error);            throw error;        }    }    // Ottieni statistiche mappa    async getMapStats() {        try {            const data = await this.makeAPICall(this.apiEndpoints.mapStats);            return data;        } catch (error) {            console.error('Failed to get map stats:', error);            throw error;        }    }    // Trova tecnici vicini    async findNearbyTechnicians(lat, lng, maxDistance = 10) {        try {            const url = `${this.apiEndpoints.nearbyTechnicians}?lat=${lat}&lng=${lng}&max_distance=${maxDistance}`;            const data = await this.makeAPICall(url);            return data;        } catch (error) {            console.error('Failed to find nearby technicians:', error);            throw error;        }    }    // Assegnazione multipla    async bulkAssignOrders(assignments) {        try {            const data = await this.makeAPICall(this.apiEndpoints.bulkAssign, 'POST', {                assignments: assignments            });            return data;        } catch (error) {            console.error('Failed to bulk assign orders:', error);            throw error;        }    }    // Calcola distanza tra due punti (Haversine formula)    calculateDistance(lat1, lng1, lat2, lng2) {        const R = 6371; // Raggio Terra in km        const dLat = this.toRad(lat2 - lat1);        const dLng = this.toRad(lng2 - lng1);                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +                  Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) *                  Math.sin(dLng/2) * Math.sin(dLng/2);                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));        return R * c;    }    toRad(degrees) {        return degrees * (Math.PI / 180);    }    // Formatta distanza per display    formatDistance(km) {        if (km < 1) {            return `${Math.round(km * 1000)}m`;        } else if (km < 10) {            return `${km.toFixed(1)}km`;        } else {            return `${Math.round(km)}km`;        }    }    // Stima tempo di viaggio (semplificata)    estimateTravelTime(distanceKm, trafficFactor = 1.2) {        // Velocità media 30 km/h in città con fattore traffico        const avgSpeedKmh = 30 / trafficFactor;        const timeHours = distanceKm / avgSpeedKmh;        const timeMinutes = Math.ceil(timeHours * 60);                if (timeMinutes < 60) {            return `${timeMinutes} min`;        } else {            const hours = Math.floor(timeMinutes / 60);            const minutes = timeMinutes % 60;            return `${hours}h ${minutes}m`;        }    }    // Ottimizza percorsi (algoritmo TSP semplificato)    optimizeRoutes(technicians, orders) {        const optimizedRoutes = [];                // Per ogni tecnico, trova gli ordini più vicini        technicians.forEach(tech => {            if (!tech.lat || !tech.lng) return;                        const techOrders = orders                .filter(order => !order.technician_id) // Solo ordini non assegnati                .map(order => ({                    ...order,                    distance: this.calculateDistance(tech.lat, tech.lng, order.lat, order.lng)                }))                .sort((a, b) => {                    // Ordina per priorità e distanza                    const priorityWeight = { 'URGENT': 4, 'HIGH': 3, 'NORMAL': 2, 'LOW': 1 };                    const aScore = priorityWeight[a.priority] * 10 - a.distance;                    const bScore = priorityWeight[b.priority] * 10 - b.distance;                    return bScore - aScore;                })                .slice(0, 3); // Max 3 ordini per tecnico                        if (techOrders.length > 0) {                optimizedRoutes.push({                    technician: tech,                    orders: techOrders,                    totalDistance: techOrders.reduce((sum, order) => sum + order.distance, 0)                });            }        });                return optimizedRoutes;    }    // Geolocalizzazione browser    async getCurrentPosition() {        return new Promise((resolve, reject) => {            if (!navigator.geolocation) {                reject(new Error('Geolocation not supported'));                return;            }                        navigator.geolocation.getCurrentPosition(                position => {                    resolve({                        lat: position.coords.latitude,                        lng: position.coords.longitude,                        accuracy: position.coords.accuracy                    });                },                error => {                    reject(error);                },                {                    enableHighAccuracy: true,                    timeout: 10000,                    maximumAge: 300000 // 5 minuti                }            );        });    }    // Geocoding inverso semplificato (usando Nominatim)    async reverseGeocode(lat, lng) {        try {            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`;            const response = await fetch(url);            const data = await response.json();                        if (data && data.display_name) {                return {                    address: data.display_name,                    city: data.address?.city || data.address?.town || data.address?.village,                    postcode: data.address?.postcode,                    country: data.address?.country                };            }        } catch (error) {            console.error('Reverse geocoding failed:', error);        }                return { address: `${lat}, ${lng}` };    }    // Export dati mappa in vari formati    exportMapData(technicians, orders, format = 'json') {        const data = {            export_date: new Date().toISOString(),            technicians: technicians,            orders: orders,            summary: {                total_technicians: technicians.length,                active_technicians: technicians.filter(t => t.is_active).length,                total_orders: orders.length,                urgent_orders: orders.filter(o => o.priority === 'URGENT').length            }        };                let content, filename, mimeType;                switch (format) {            case 'csv':                content = this.convertToCSV(data);                filename = `map_export_${new Date().toISOString().split('T')[0]}.csv`;                mimeType = 'text/csv';                break;                            case 'json':            default:                content = JSON.stringify(data, null, 2);                filename = `map_export_${new Date().toISOString().split('T')[0]}.json`;                mimeType = 'application/json';                break;        }                this.downloadFile(content, filename, mimeType);    }    // Converte dati in CSV    convertToCSV(data) {        let csv = 'Tipo,Nome,Telefono,Stato,Priorità,Coordinate,Note\n';                // Tecnici        data.technicians.forEach(tech => {            csv += `Tecnico,"${tech.name}","${tech.phone}","${tech.is_active ? 'Attivo' : 'Inattivo'}",,"${tech.lat || ''};${tech.lng || ''}","${tech.vehicle || ''}"\n`;        });                // Ordini        data.orders.forEach(order => {            csv += `Ordine,"${order.customer_name}","${order.customer_phone || ''}","${order.status}","${order.priority}","${order.lat || ''};${order.lng || ''}","${order.title}"\n`;        });                return csv;    }    // Download file    downloadFile(content, filename, mimeType) {        const blob = new Blob([content], { type: mimeType });        const url = URL.createObjectURL(blob);                const a = document.createElement('a');        a.href = url;        a.download = filename;        a.style.display = 'none';                document.body.appendChild(a);        a.click();        document.body.removeChild(a);                URL.revokeObjectURL(url);    }    // Notifiche toast    showToast(message, type = 'info', duration = 3000) {        // Rimuovi toast esistenti dello stesso tipo        const existingToasts = document.querySelectorAll(`.toast-${type}`);        existingToasts.forEach(toast => toast.remove());                const toast = document.createElement('div');        toast.className = `alert alert-${type} alert-dismissible fade show position-fixed toast-${type}`;        toast.style.cssText = `            top: 20px;            right: 20px;            z-index: 9999;            min-width: 300px;            max-width: 400px;            box-shadow: 0 4px 12px rgba(0,0,0,0.15);            border: none;            animation: slideInRight 0.3s ease-out;        `;                const iconMap = {            success: 'check-circle',            danger: 'exclamation-triangle',            warning: 'exclamation-triangle',            info: 'info-circle'        };                toast.innerHTML = `            <i class="fas fa-${iconMap[type] || 'info-circle'} me-2"></i>            ${message}            <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>        `;                document.body.appendChild(toast);                // Auto-remove        setTimeout(() => {            if (toast.parentNode) {                toast.style.animation = 'slideOutRight 0.3s ease-in';                setTimeout(() => toast.remove(), 300);            }        }, duration);                return toast;    }    // Animazioni CSS dinamiche    addCustomStyles() {        if (document.getElementById('map-custom-styles')) return;                const style = document.createElement('style');        style.id = 'map-custom-styles';        style.textContent = `            @keyframes slideInRight {                from { transform: translateX(100%); opacity: 0; }                to { transform: translateX(0); opacity: 1; }            }                        @keyframes slideOutRight {                from { transform: translateX(0); opacity: 1; }                to { transform: translateX(100%); opacity: 0; }            }                        .map-marker-bounce {                animation: markerBounce 0.6s ease-out;            }                        @keyframes markerBounce {                0%, 20%, 53%, 80%, 100% { transform: translate3d(0,0,0); }                40%, 43% { transform: translate3d(0,-10px,0); }                70% { transform: translate3d(0,-5px,0); }                90% { transform: translate3d(0,-2px,0); }            }        `;                document.head.appendChild(style);    }    // Debug e logging    enableDebugMode() {        this.debugMode = true;        console.log('DispatchMap Debug Mode enabled');                // Aggiungi indicatore debug        const debugIndicator = document.createElement('div');        debugIndicator.innerHTML = `            <div style="                position: fixed;                bottom: 10px;                left: 10px;                background: rgba(255,0,0,0.8);                color: white;                padding: 5px 10px;                border-radius: 5px;                font-size: 12px;                z-index: 10000;            ">                DEBUG MODE            </div>        `;        document.body.appendChild(debugIndicator);    }    debug(...args) {        if (this.debugMode) {            console.log('[DispatchMap]', ...args);        }    }    // Inizializzazione    init() {        this.addCustomStyles();        this.debug('DispatchMapUtils initialized');                // Event listeners globali        document.addEventListener('visibilitychange', () => {            if (document.visibilityState === 'visible' && this.isAutoRefreshing) {                this.debug('Page visible, refreshing map data');                this.refreshMapData();            }        });                // Gestore errori globale        window.addEventListener('error', (event) => {            this.debug('Global error:', event.error);        });    }}// Instanza globaleconst mapUtils = new DispatchMapUtils();// Auto-inizializzazione quando il DOM è prontoif (document.readyState === 'loading') {    document.addEventListener('DOMContentLoaded', () => mapUtils.init());} else {    mapUtils.init();}// Esporta per uso globalewindow.DispatchMapUtils = DispatchMapUtils;window.mapUtils = mapUtils;